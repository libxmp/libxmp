!ifeq USE_PROWIZARD 0
CFLAGS += -DLIBXMP_NO_PROWIZARD
!endif
!ifeq USE_DEPACKERS 0
CFLAGS += -DLIBXMP_NO_DEPACKERS
!endif
CFLAGS += -DHAVE_FNMATCH -DHAVE_MKSTEMP -DHAVE_UMASK
#CFLAGS += -DDEBUG
CFLAGS += -Iinclude

DLLFLAGS=-bd -DBUILDING_DLL
STATICFLAGS=-DLIBXMP_STATIC

LIBROOTDIR=lib
OBJROOTDIR=obj
!ifeq __LINUX__
PATHSEP=/
!else
# Under MS-DOS, Windows, and OS/2 we use the shell's mkdir and
# rmdir, so we need a backslashes instead of forward slashes.
PATHSEP=\
!endif

LIBDIR=$(LIBROOTDIR)$(PATHSEP)$(SYSTEM)
OBJDIR=$(OBJROOTDIR)$(PATHSEP)$(SYSTEM)
LOADERSOBJDIR=$(OBJDIR)$(PATHSEP)loaders
PROWIZARDOBJDIR=$(OBJDIR)$(PATHSEP)loaders$(PATHSEP)prowizard
DEPACKERSOBJDIR=$(OBJDIR)$(PATHSEP)depackers

# CLEAN_DIRS is the same as ALL_DIRS but in reverse order. We use this when cleaning
# because on OS/2 there's no way to recursively remove directories, so we have to
# remove directories in a depth-first manner.
CLEAN_DIRS=
ALL_DIRS=$(LIBROOTDIR) $(OBJROOTDIR) $(LIBDIR) $(OBJDIR) $(LOADERSOBJDIR)
!ifeq USE_PROWIZARD 1
CLEAN_DIRS += $(PROWIZARDOBJDIR)
ALL_DIRS += $(PROWIZARDOBJDIR)
!endif
!ifeq USE_DEPACKERS 1
CLEAN_DIRS += $(DEPACKERSOBJDIR)
ALL_DIRS += $(DEPACKERSOBJDIR)
!endif
CLEAN_DIRS += $(LOADERSOBJDIR) $(OBJDIR) $(LIBDIR)

!ifdef __OS2__
CLEAN_DIRS_ARGS=/N
!else ifndef __LINUX__
CLEAN_DIRS_ARGS=/Q
!endif

DLLNAME=$(LIBDIR)/libxmp.dll
EXPNAME=$(LIBDIR)/libxmp.exp
# Note: not libxmp.map...
MAPNAME=$(LIBDIR)/xmp.map
LIBNAME=$(LIBDIR)/libxmp.lib
LIBSTATIC=$(LIBDIR)/xmp_static.lib
TESTNAME=libxmp-test.exe

!ifeq target static
CFLAGS += $(STATICFLAGS)
LIBFLAGS=$(CFLAGS)
BLD_TARGET=$(LIBSTATIC)
BLD_LIB=$(LIBSTATIC)
!else
LIBFLAGS=$(CFLAGS) $(DLLFLAGS)
BLD_TARGET=$(DLLNAME)
BLD_LIB=$(LIBNAME)
!endif

OBJS=@OBJS@
PROWIZ_OBJS=@POBJS@
DEPACKER_OBJS=@DOBJS@

ALL_OBJS_TEMP=$(OBJS)
!ifeq USE_PROWIZARD 1
ALL_OBJS_TEMP+= $(PROWIZ_OBJS)
!endif
!ifeq USE_DEPACKERS 1
ALL_OBJS_TEMP+= $(DEPACKER_OBJS)
!endif

# Now replace src/ directory prefix with obj/
ALL_OBJS=$(ALL_OBJS_TEMP:src/=$(OBJDIR)/)
TEST_OBJS=test/md5.obj test/test.obj

all: $(ALL_DIRS) $(BLD_TARGET)

#.SUFFIXES: .obj .c

$(ALL_DIRS):
!ifeq __LINUX__
	mkdir -p $(ALL_DIRS)
!else
	@!for %i in ($(ALL_DIRS)) do @if not exist %i echo mkdir %i && mkdir %i
!endif

.c: src;src/depackers;src/loaders;src/loaders/prowizard;test
.c.obj:
	$(CC) $(LIBFLAGS) -fo=$^@ $<

test/md5.obj: src/md5.c
	$(CC) $(CFLAGS) -fo=$^@ $<

test/test.obj: test/test.c
	$(CC) $(CFLAGS) -fo=$^@ $<

# rely on symbol name, not ordinal: -irn switch of wlib is default, but -inn is not.
$(DLLNAME) $(LIBNAME) $(EXPNAME): $(ALL_OBJS)
	wlink NAM $(DLLNAME) SYSTEM $(SYSTEM_DLL) INITINSTANCE TERMINSTANCE OP QUIET FIL {$(ALL_OBJS)} OP IMPF=$(EXPNAME) OP MAP=$(MAPNAME)
	wlib -q -b -n -c -pa -s -t -zld -ii -io -inn $(LIBNAME) +$(DLLNAME)

$(LIBSTATIC): $(ALL_OBJS)
	wlib -q -b -n -c -pa -s -t -zld -ii -io $@ $(ALL_OBJS)

test/$(TESTNAME): $(BLD_LIB) $(TEST_OBJS)
	wlink NAM test/$(TESTNAME) SYSTEM $(SYSTEM) OP QUIET LIBR {$(BLD_LIB)} FIL {$(TEST_OBJS)}

check-build: test/$(TESTNAME) .symbolic
!ifneq target static
	$(CMD_CP) $(DLLNAME) test
!endif

check: check-build .symbolic
	cd test & $(TESTNAME)

clean: .symbolic
	rm -f $(ALL_OBJS)
	rm -f $(TEST_OBJS)
!ifeq __LINUX__
	rm -rf $(CLEAN_DIRS)
!else
	@!for %i in ($(CLEAN_DIRS)) do @if exist %i\*.* echo del $(CLEAN_DIRS_ARGS) %i\*.* && del $(CLEAN_DIRS_ARGS) %i\*.* 2> nul
	@!for %i in ($(CLEAN_DIRS)) do @if exist %i echo rmdir %i && rmdir %i 2> nul
!endif

distclean: clean .symbolic
	rm -f *.err
	rm -f $(DLLNAME) $(EXPNAME) $(MAPNAME) $(LIBNAME) $(LIBSTATIC) test/$(DLLNAME) test/$(TESTNAME)

!ifdef __UNIX__
CMD_CP=cp
!else
CMD_CP=copy
!endif
